<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <script id="shader-fs" type="x-shader/x-fragment">
    in vec4 vColor;
    in vec3 vNormal;
    flat in int vMaterialIndex;

    out vec4 outColor;

    // const int nMaterials = 5;
    // const int nLights = 1; 

    uniform int useColor;

    struct Material {
      vec4 baseColor, emissive, specular;
      float roughness, metallic, f0;
    };

    uniform Material objMaterial[nMaterials]; // assuming we are doing multiple materials, 

    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };
    uniform Light objLights[nLights]; // again, can be set at will by the asy generator.

    float NDF_TRG(vec3 halfv, vec3 normal, float roughness) {
      float ndoth=max(dot(normal, halfv), 0.0);
      float alpha2=roughness*roughness;
      
      float denom=pow(ndoth*ndoth*(alpha2-1.0)+1.0, 2.0);
      return alpha2/denom;
    }
    
    float GGX_Geom(vec3 v, vec3 normal, float roughness) {
      float ndotv=max(dot(v, normal), 0.0);
      float ap=pow((1.0+roughness), 2.0);
      float k=ap/8.0;
      
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l, vec3 normal, float roughness) {
      return GGX_Geom(v,normal,roughness)*GGX_Geom(l,normal,roughness);
    }
    
    float Fresnel(vec3 h, vec3 v, float f0) {
      float hdotv=max(dot(h,v), 0.0);
      return f0+(1.0-f0)*pow((1.0-hdotv),5.0);
    }
    
    // physical based shading using UE4 model.
    vec3 physBDRF(Material material, vec3 normal, vec3 lightdir, vec3 lookdir) {
      vec3 lambertian=material.baseColor.rgb;
      vec3 h=normalize(lightdir+lookdir);
      float omegain=max(dot(lookdir, normal), 0.0);
      float omegali=max(dot(lightdir, normal), 0.0);
      
      float D=NDF_TRG(h, normal, material.roughness*material.roughness);
      float G=Geom(lookdir, lightdir, normal, material.roughness*material.roughness);
      float F=Fresnel(h, lookdir, material.f0);
      
      float denom=4.0*omegain*omegali;
      if (denom == 0.0) {return vec3(0,0,0); }
      
      float rawrefl=(D*G) / denom;
      
      vec3 dielectric=mix(lambertian, rawrefl*material.specular.rgb, F);
      vec3 metal=rawrefl*material.baseColor.rgb;
      
      return mix(dielectric, metal, material.metallic);
    }
    
    void main(void)
    {
      // light dir=+Z, viewDir=+Z,

      float normalSign = gl_FrontFacing ? 1.0 : -1.0;
      
      vec3 normal=normalSign*normalize(vNormal);
      vec3 Z=vec3(0,0,1.0);
      vec3 rawCol = vec3(0.0);

      Material m=objMaterial[vMaterialIndex];

      if (useColor == 1) {
        m.baseColor = vColor;
      }

      for (int i=0;i<nLights;++i) {
        Light Li=objLights[i];
        float cosTheta = 0.0;
        float atteunation = 1.0;
        vec3 lightDirection = vec3(0.0);
        if (Li.type == DIRECTIONAL_LIGHT) {
          lightDirection = Li.parameter.xyz;
          cosTheta = max(dot(normal, lightDirection), 0.0);
        }
        vec3 radiance = cosTheta * Li.color * Li.brightness;
        rawCol += physBDRF(m, normal, lightDirection, Z) * radiance;
      }
      outColor=vec4(rawCol,1);
    }
  </script>

  <script id="shader-vs" type="x-shader/x-vertex">
    in vec3 aVertexPosition;
    in vec4 aVertexColor;
    in vec3 aVertexNormal;
    in int aVertexMaterialIndex;

    uniform mat4 uNormMatrix;
    uniform mat4 uPVMatrix;
    
    out vec4 vColor;
    out vec3 vNormal;
    flat out int vMaterialIndex;
    
    void main(void) {
      gl_Position=uPVMatrix*vec4(aVertexPosition,1.0);  
      vec4 rawNormal=uNormMatrix*vec4(aVertexNormal,0.0);
      vNormal=normalize(rawNormal.xyz);
      
      vColor=aVertexColor;
      vMaterialIndex=aVertexMaterialIndex;
    }
    
  </script>

  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="gl.js"></script>
  <script type="text/javascript">
    P.push([
      [-218.340556372384, 45.4819741822066, -1838.27841917763],
      [-218.340556372384, 0.827152274922852, -1864.53633910364],
      [-177.136637779296, -41.8717875626246, -1843.02091286394],
      [-177.136637779296, -49.3142963883844, -1847.397255495],
      [-128.315002783561, 92.2655859172091, -1917.83970415728],
      [-128.315002783561, 47.6107640099253, -1944.09762408329],
      [-109.617479676745, -6.78408244535024, -1902.69187033362],
      [-109.617479676745, -14.2265912711101, -1907.06821296468],
      [14.9382926606397, 93.1701537735415, -1919.37803303639],
      [14.9382926606397, 48.5153318662577, -1945.6359529624],
      [-2.17745066565886, -6.10565619047435, -1903.84561760965],
      [-2.17745066565886, -13.5481650162342, -1908.22196024071],
      [107.235120312431, 47.5378102522916, -1841.77462123168],
      [107.235120312431, 2.88298834500783, -1868.03254115768],
      [67.0451628052669, -40.3299102380909, -1845.64306486699],
      [67.0451628052669, -47.7724190638507, -1850.01940749806]
    ]);

    pMatrix=new Float32Array([
    5.80703020095825, 0, 0, 0, 
    0, 7.92853212356567, 0, 0, 
    0, 0, -3.64913606643677, -1, 
    0, 0, -5552.96923828125, 0, 
    ]);

    var materialIndex = 0;

    var objMaterials = [new Material(
      baseColor = [1, 1, 0, 1],
      emissive = [0, 0, 0, 1],
      specular = [1, 1, 1, 1],
      roughness = 0.15,
      metallic = 0,
      f0 = 0.04
    )];

    var lights = [
    new Light(
      type = enumDirectionalLight,
      lightColor = [1, 0.87, 0.745],
      brightness = 1,
      customParam = [0, 0, 1, 0]
    )];

    // Lighting parameters
    var L = [0.447735768366173, 0.497260947684137, 0.743144825477394];
    var Ambient = [0.1, 0.1, 0.1];
    var Diffuse = [0.8, 0.8, 0.8, 1];
    var Specular = [0.7, 0.7, 0.7, 1];
    var specularfactor = 3;

    // Material parameters
    var emissive = [0, 0, 0, 1];
    var ambient = [0, 0, 0, 1];
    var diffuse = [1, 0, 0, 1];
    var specular = [0.75, 0.75, 0.75, 1];
    var shininess = 0.5;

    var cameraPos = vec3.fromValues(0, 0, 2);
    var cameraLookAt = vec3.fromValues(0, 0, 0);
    var cameraUp = vec3.fromValues(1, 0, 0);

    var canvWidth=800;
    var canvHeight=800;

    //    projViewMat:
    // 5.80703020095825, 0, 0, 0, 
    //0, 7.92853212356567, 0, 0, 
    // 0, 0, -3.64913606643677, -1, 
    // 0, 0, -5552.96923828125, 0, 
  </script>

</head>


<body onload="webGLStart();">
  <script type="text/javascript" id="eventfunc">
    forceredraw = true;
    var totaltime=0;
    function processloop(deltams) {
      totaltime += deltams/1000;
      // enter arbitrary processing event here
      // if one wants to modify the object per tick.
      objMaterials[0].baseColor[1] = (0.5 + 0.5*Math.sin(totaltime));
    }
  </script>
  <canvas id="Asymptote" style="border: none;" width="0" height="0"></canvas>
</body>

</html>