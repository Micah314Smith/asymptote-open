<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <meta name="viewport" content="user-scalable=no"/>

  <script id="fragment" type="x-shader/x-fragment">
#ifdef NORMAL
    varying vec4 ViewPosition;
    varying vec3 Normal;
    varying vec4 diffuse;
    varying vec4 specular;
    varying float roughness,metallic,fresnel0;

    float Roughness2;
    vec3 normal;

    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };
    uniform Light objLights[nLights];

    float NDF_TRG(vec3 h) {
      float ndoth=max(dot(normal,h),0.0);
      float alpha2=Roughness2*Roughness2;
      float denom=ndoth*ndoth*(alpha2-1.0)+1.0;
      return denom != 0.0 ? alpha2/(denom*denom) : 0.0;
    }
    
    float GGX_Geom(vec3 v) {
      float ndotv=max(dot(v,normal),0.0);
      float ap=1.0+Roughness2;
      float k=0.125*ap*ap;
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l) {
      return GGX_Geom(v)*GGX_Geom(l);
    }
    
    float Fresnel(vec3 h, vec3 v, float fresnel0) {
      float a=1.0-max(dot(h,v),0.0);
      float b=a*a;
      return fresnel0+(1.0-fresnel0)*b*b*a;
    }
    
    // physical based shading using UE4 model.
    vec3 BRDF(vec3 viewDirection, vec3 lightDirection) {
      vec3 lambertian=diffuse.rgb;
      vec3 h=normalize(lightDirection+viewDirection);
      
      float omegain=max(dot(viewDirection,normal),0.0);
      float omegali=max(dot(lightDirection,normal),0.0);
      
      float D=NDF_TRG(h);
      float G=Geom(viewDirection,lightDirection);
      float F=Fresnel(h,viewDirection,fresnel0);
      
      float denom=4.0*omegain*omegali;
      float rawReflectance=denom > 0.0 ? (D*G)/denom : 0.0;
      
      vec3 dielectric=mix(lambertian,rawReflectance*specular.rgb,F);
      vec3 metal=rawReflectance*diffuse.rgb;
      
      return mix(dielectric,metal,metallic);
    }
#endif
    varying vec4 emissive;
    
    void main(void)
    {
#ifdef NORMAL
      normal=normalize(Normal);
      normal=gl_FrontFacing ? normal : -normal;
//#ifdef ORTHOGRAPHIC
      vec3 viewDir=vec3(0,0,1.0);
//#else
//      vec3 viewDir=-normalize(ViewPosition.xyz/ViewPosition.w);
//#endif

      Roughness2=roughness*roughness;
      vec3 color=emissive.rgb;
      vec3 Z=vec3(0.0,0.0,1.0);

      for (int i=0; i < nLights; ++i) {
        Light Li=objLights[i];
        vec3 L=Li.parameter.xyz;
        float cosTheta=max(dot(normal,L),0.0);
        vec3 radiance=cosTheta*Li.color*Li.brightness;
        color += BRDF(viewDir,L)*radiance;
      }
      gl_FragColor=vec4(color,diffuse.a);
#else
      gl_FragColor=emissive;
#endif
    }
  </script>

  <script id="vertex" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec3 normal;
    attribute float materialIndex;
    attribute float centerIndex;
#ifdef TRANSPARENT
    attribute vec4 color;
#endif
#ifdef COLOR
    attribute vec4 color;
#endif

    uniform mat3 normMat;
    uniform mat4 viewMat;
    uniform mat4 projViewMat;

#ifdef NORMAL
    varying vec4 ViewPosition;
    varying vec3 Normal;
    varying vec4 diffuse;
    varying vec4 specular;
    varying float roughness,metallic,fresnel0;
#endif
    varying vec4 emissive;

    struct Material {
      vec4 diffuse,emissive,specular;
      float shininess,metallic,fresnel0;
    };

    uniform Material objMaterial[nMaterials];
    uniform vec3 Centers[nCenters];

    void main(void) {
      int index=int(centerIndex);
      vec4 v=vec4(index == 0 ? position :
                  Centers[index-1]+normMat*(position-Centers[index-1]),1.0);
      gl_Position=projViewMat*v;
#ifdef NORMAL
      ViewPosition=viewMat*v;
      Normal=normal*normMat;
        
      Material m;
#ifdef TRANSPARENT
      m=objMaterial[int(abs(materialIndex))-1];
      if(materialIndex >= 0.0) {
        diffuse=m.diffuse;
        emissive=m.emissive;
      } else {
        diffuse=color;
        emissive=vec4(0.0);
      }
#else      
      m=objMaterial[int(materialIndex)];
#ifdef COLOR
      diffuse=color;
      emissive=vec4(0.0);
#else
      diffuse=m.diffuse;
      emissive=m.emissive;
#endif
#endif
      specular=m.specular;
      roughness=1.0-m.shininess;
      metallic=m.metallic;
      fresnel0=m.fresnel0;
#else
      emissive=objMaterial[int(materialIndex)].emissive;
#endif
    }
</script>

  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="gl.js"></script>
  <script type="text/javascript">
