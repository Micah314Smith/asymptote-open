<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <script id="shader-fs" type="x-shader/x-fragment">
    in vec4 vColor;
    in vec4 vViewPosition;
    in vec3 vNormal;
    flat in int vMaterialIndex;

    out vec4 outColor;
    uniform int useColor;

    struct Material {
      vec4 diffuse, emissive, specular;
      float shininess, metallic, fresnel0;
    };

    uniform Material objMaterial[nMaterials];

    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };
    uniform Light objLights[nLights];

    float NDF_TRG(vec3 halfv, vec3 normal, float roughness) {
      float ndoth=max(dot(normal, halfv), 0.0);
      float alpha2=roughness*roughness;
      
      float denom=pow(ndoth*ndoth*(alpha2-1.0)+1.0, 2.0);
      return alpha2/denom;
    }
    
    float GGX_Geom(vec3 v, vec3 normal, float roughness) {
      float ndotv=max(dot(v, normal), 0.0);
      float ap=pow((1.0+roughness), 2.0);
      float k=ap/8.0;
      
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l, vec3 normal, float roughness) {
      return GGX_Geom(v,normal,roughness)*GGX_Geom(l,normal,roughness);
    }
    
    float Fresnel(vec3 h, vec3 v, float fresnel0) {
      float hdotv=max(dot(h,v), 0.0);
      return fresnel0+(1.0-fresnel0)*pow((1.0-hdotv),5.0);
    }
    
    // physical based shading using UE4 model.
    vec3 physBDRF(Material material, vec3 normal, vec3 lightdir, vec3 lookdir) {
      vec3 lambertian=material.diffuse.rgb;
      vec3 h=normalize(lightdir+lookdir);
      float omegain=max(dot(lookdir, normal), 0.0);
      float omegali=max(dot(lightdir, normal), 0.0);
      float roughness=1.0-material.shininess;
      
      float D=NDF_TRG(h, normal, roughness*roughness);
      float G=Geom(lookdir, lightdir, normal, roughness*roughness);
      float F=Fresnel(h, lookdir, material.fresnel0);
      
      float denom=4.0*omegain*omegali;
      if (denom == 0.0) {return vec3(0,0,0); }
      
      float rawrefl=(D*G) / denom;
      
      vec3 dielectric=mix(lambertian, rawrefl*material.specular.rgb, F);
      vec3 metal=rawrefl*material.diffuse.rgb;
      
      return mix(dielectric, metal, material.metallic);
    }
    
    void main(void)
    {
      // light dir=+Z, viewDir=+Z,

      float normalSign = gl_FrontFacing ? 1.0 : -1.0;
      
      vec3 normal=normalSign*normalize(vNormal);
      vec3 Z=vec3(0,0,1.0);
#ifdef ORTHOGRAPHIC
      vec3 viewDir=Z;
#else
      vec3 viewDir=-normalize(vViewPosition.xyz/vViewPosition.w);
#endif

      Material m=objMaterial[vMaterialIndex];

      vec3 rawCol = m.emissive.xyz;

      if (useColor == 1) {
        m.diffuse = vColor;
      }

      for (int i=0;i<nLights;++i) {
        Light Li=objLights[i];
        float cosTheta = 0.0;
        float atteunation = 1.0;
        vec3 lightDirection = vec3(0.0);
        if (Li.type == DIRECTIONAL_LIGHT) {
          lightDirection = Li.parameter.xyz;
          cosTheta = max(dot(normal, lightDirection), 0.0);
        }
        vec3 radiance = cosTheta * Li.color * Li.brightness;
        rawCol += physBDRF(m, normal, lightDirection, viewDir) * radiance;
      }
      outColor=vec4(rawCol,m.diffuse.a);
    }
  </script>

  <script id="shader-vs" type="x-shader/x-vertex">
    in vec3 aVertexPosition;
    in vec4 aVertexColor;
    in vec3 aVertexNormal;
    in int aVertexMaterialIndex;

    uniform mat4 uNormMatrix;
    uniform mat4 uVMMatrix;
    uniform mat4 uPVMatrix;
    
    out vec4 vColor;
    out vec3 vNormal;
    out vec4 vViewPosition;

    flat out int vMaterialIndex;
    
    void main(void) {
      gl_Position=uPVMatrix*vec4(aVertexPosition,1.0);
      vViewPosition=uVMMatrix*vec4(aVertexPosition,1.0);

      vec4 rawNormal=uNormMatrix*vec4(aVertexNormal,0.0);
      vNormal=normalize(rawNormal.xyz);
      
      vColor=aVertexColor;
      vMaterialIndex=aVertexMaterialIndex;
    }
  </script>

  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="webgl/gl.js"></script>
  <script type="text/javascript">
