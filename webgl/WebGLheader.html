<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <script id="fragment" type="x-shader/x-fragment">
    varying vec4 vViewPosition;
    varying vec3 vNormal;
    varying vec4 diffuse,emissive,specular;
    varying float roughness,metallic,fresnel0;
#ifdef EXPLICIT_COLORS
    varying vec4 vColor;
#endif

    vec4 outColor;
    vec4 Diffuse;


    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };
    uniform Light objLights[nLights];

    float NDF_TRG(vec3 halfv, vec3 normal, float roughness) {
      float ndoth=max(dot(normal, halfv), 0.0);
      float alpha2=roughness*roughness;
      
      float denom=pow(ndoth*ndoth*(alpha2-1.0)+1.0, 2.0);
      return alpha2/denom;
    }
    
    float GGX_Geom(vec3 v, vec3 normal, float roughness) {
      float ndotv=max(dot(v, normal), 0.0);
      float ap=pow((1.0+roughness), 2.0);
      float k=ap/8.0;
      
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l, vec3 normal, float roughness) {
      return GGX_Geom(v,normal,roughness)*GGX_Geom(l,normal,roughness);
    }
    
    float Fresnel(vec3 h, vec3 v, float fresnel0) {
      float hdotv=max(dot(h,v), 0.0);
      return fresnel0+(1.0-fresnel0)*pow((1.0-hdotv),5.0);
    }
    
    // physical based shading using UE4 model.
    vec3 physBDRF(vec3 normal, vec3 lightdir, vec3 lookdir) {
      vec3 lambertian=Diffuse.rgb;
      vec3 h=normalize(lightdir+lookdir);
      float omegain=max(dot(lookdir, normal), 0.0);
      float omegali=max(dot(lightdir, normal), 0.0);
      
      float D=NDF_TRG(h, normal, roughness*roughness);
      float G=Geom(lookdir, lightdir, normal, roughness*roughness);
      float F=Fresnel(h, lookdir, fresnel0);
      
      float denom=4.0*omegain*omegali;
      float rawReflectance;
      if(denom > 0.0)
        rawReflectance=(D*G)/denom;
      else 
        rawReflectance=0.0;
      
      vec3 dielectric=mix(lambertian, rawReflectance*specular.rgb, F);
      vec3 metal=rawReflectance*Diffuse.rgb;
      
      return mix(dielectric, metal, metallic);
    }
    
    void main(void)
    {
      float normalSign=gl_FrontFacing ? 1.0 : -1.0;
      
      vec3 normal=normalSign*normalize(vNormal);
#ifdef ORTHOGRAPHIC
      vec3 viewDir=vec3(0,0,1.0);
#else
      vec3 viewDir=-normalize(vViewPosition.xyz/vViewPosition.w);
#endif

      vec3 rawCol = emissive.xyz;

#ifdef EXPLICIT_COLORS
        Diffuse=vColor;
#else
        Diffuse=diffuse;
#endif

      for (int i=0; i<nLights; ++i) {
        Light Li=objLights[i];
        float cosTheta=0.0;
        float atteunation=1.0;
        vec3 lightDirection = vec3(0.0);
        if (Li.type == DIRECTIONAL_LIGHT) {
          lightDirection=Li.parameter.xyz;
          cosTheta=max(dot(normal,lightDirection),0.0);
        }
        vec3 radiance=cosTheta*Li.color*Li.brightness;
        rawCol += physBDRF(normal,lightDirection,viewDir)*radiance;
      }
      gl_FragColor=vec4(rawCol,Diffuse.a);
    }
  </script>

  <script id="vertex" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute float aVertexMaterialIndex;
    attribute vec4 aColor;

    uniform mat4 uNormMatrix;
    uniform mat4 uVMMatrix;
    uniform mat4 uPVMatrix;
    
    varying vec4 vViewPosition;
    varying vec3 vNormal;
    varying vec4 diffuse,emissive,specular;
    varying float roughness,metallic,fresnel0;
#ifdef EXPLICIT_COLORS
    varying vec4 vColor;
#endif

    struct Material {
      vec4 diffuse,emissive,specular;
      float shininess,metallic,fresnel0;
    };

    uniform Material objMaterial[nMaterials];

    void main(void) {
      gl_Position=uPVMatrix*vec4(aVertexPosition,1.0);
      vViewPosition=uVMMatrix*vec4(aVertexPosition,1.0);

      vec4 rawNormal=uNormMatrix*vec4(aVertexNormal,0.0);
      vNormal=normalize(rawNormal.xyz);
      
      Material m=objMaterial[int(aVertexMaterialIndex)];
      diffuse=m.diffuse;
      emissive=m.emissive;
      specular=m.specular;
      roughness=1.0-m.shininess;
      metallic=m.metallic;
      fresnel0=m.fresnel0;

#ifdef EXPLICIT_COLORS
      vColor=aColor;
#endif
    }
  </script>

  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="webgl/gl.js"></script>
  <script type="text/javascript">
