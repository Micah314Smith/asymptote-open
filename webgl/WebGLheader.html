<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <script id="fragment" type="x-shader/x-fragment">
    varying vec4 ViewPosition;
    varying vec3 Normal;
    varying vec4 diffuse,emissive,specular;
    varying float roughness,metallic,fresnel0;

    vec4 outColor;

    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };
    uniform Light objLights[nLights];

    float NDF_TRG(vec3 halfv, vec3 normal, float roughness) {
      float ndoth=max(dot(normal, halfv), 0.0);
      float alpha2=roughness*roughness;
      
      float denom=pow(ndoth*ndoth*(alpha2-1.0)+1.0, 2.0);
      return alpha2/denom;
    }
    
    float GGX_Geom(vec3 v, vec3 normal, float roughness) {
      float ndotv=max(dot(v, normal), 0.0);
      float ap=pow((1.0+roughness), 2.0);
      float k=ap/8.0;
      
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l, vec3 normal, float roughness) {
      return GGX_Geom(v,normal,roughness)*GGX_Geom(l,normal,roughness);
    }
    
    float Fresnel(vec3 h, vec3 v, float fresnel0) {
      float hdotv=max(dot(h,v), 0.0);
      return fresnel0+(1.0-fresnel0)*pow((1.0-hdotv),5.0);
    }
    
    // physical based shading using UE4 model.
    vec3 physBDRF(vec3 normal, vec3 lightdir, vec3 lookdir) {
      vec3 lambertian=diffuse.rgb;
      vec3 h=normalize(lightdir+lookdir);
      float omegain=max(dot(lookdir, normal), 0.0);
      float omegali=max(dot(lightdir, normal), 0.0);
      
      float D=NDF_TRG(h, normal, roughness*roughness);
      float G=Geom(lookdir, lightdir, normal, roughness*roughness);
      float F=Fresnel(h, lookdir, fresnel0);
      
      float denom=4.0*omegain*omegali;
      float rawReflectance;
      if(denom > 0.0)
        rawReflectance=(D*G)/denom;
      else 
        rawReflectance=0.0;
      
      vec3 dielectric=mix(lambertian, rawReflectance*specular.rgb, F);
      vec3 metal=rawReflectance*diffuse.rgb;
      
      return mix(dielectric, metal, metallic);
    }
    
    void main(void)
    {
      float normalSign=gl_FrontFacing ? 1.0 : -1.0;
      
      vec3 normal=normalSign*normalize(Normal);
#ifdef ORTHOGRAPHIC
      vec3 viewDir=vec3(0,0,1.0);
#else
      vec3 viewDir=-normalize(ViewPosition.xyz/ViewPosition.w);
#endif

      vec3 rawCol = emissive.xyz;

      for (int i=0; i<nLights; ++i) {
        Light Li=objLights[i];
        float cosTheta=0.0;
        float atteunation=1.0;
        vec3 lightDirection = vec3(0.0);
        if (Li.type == DIRECTIONAL_LIGHT) {
          lightDirection=Li.parameter.xyz;
          cosTheta=max(dot(normal,lightDirection),0.0);
        }
        vec3 radiance=cosTheta*Li.color*Li.brightness;
        rawCol += physBDRF(normal,lightDirection,viewDir)*radiance;
      }
      gl_FragColor=vec4(rawCol,diffuse.a);
    }
  </script>

  <script id="vertex" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec3 normal;
    attribute float materialIndexf;
    attribute vec4 color;

    uniform mat4 normMat;
    uniform mat4 viewMat;
    uniform mat4 projViewMat;
    
    varying vec4 ViewPosition;
    varying vec3 Normal;
    varying vec4 diffuse,emissive,specular;
    varying float roughness,metallic,fresnel0;

    struct Material {
      vec4 diffuse,emissive,specular;
      float shininess,metallic,fresnel0;
    };

    uniform Material objMaterial[nMaterials];

    void main(void) {
      gl_Position=projViewMat*vec4(position,1.0);
      ViewPosition=viewMat*vec4(position,1.0);

      Normal=(normMat*vec4(normal,0)).xyz;
      
      Material m;
      int materialIndex=int(materialIndexf);
#ifdef EXPLICIT_COLORS
      if(materialIndex < 0) {
        int index=-materialIndex-1;
        m=objMaterial[index];
        diffuse=color;
        emissive=vec4(0.0);
      } else {
        m=objMaterial[materialIndex];
        diffuse=m.diffuse;
        emissive=m.emissive;
      }
#else
      m=objMaterial[materialIndex];
      diffuse=m.diffuse;
      emissive=m.emissive;
#endif
      specular=m.specular;
      roughness=1.0-m.shininess;
      metallic=m.metallic;
      fresnel0=m.fresnel0;
    }
  </script>

  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
  <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="webgl/gl.js"></script>
  <script type="text/javascript">
